#!/usr/bin/env bash
set -euo pipefail

ROOT="${HOME}/Desktop/dlog"

echo "[dlog] refolding Omega workspace into ${ROOT}"
mkdir -p "${ROOT}"
cd "${ROOT}"

########################################
# Root workspace
########################################

cat > Cargo.toml << 'EOF'
[workspace]
members = [
    "spec",
    "corelib",
    "core",
    "api",
]
resolver = "2"

[workspace.dependencies]
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
axum = { version = "0.7", features = ["ws"] }
tokio = { version = "1.37", features = ["full"] }
tracing = "0.1"
tracing-subscriber = { version = "0.3", features = ["env-filter"] }
thiserror = "1.0"
futures = "0.3"
EOF

cat > .gitignore << 'EOF'
/target
**/*.rs.bk
Cargo.lock
EOF

cat > README.md << 'EOF'
# dlog Omega workspace

This tree is generated by refold.command.
Crates:

- spec: monetary and network constants (PHI, APY, rails, block timing).
- corelib: shared data types and serde models.
- core: pure logic over the Omega spec.
- api: Axum HTTP API on :8080 exposing /health, /v1/spec/*, /v1/paper/status, and /ws/paper (WebSocket bridge to a Paper host/port set via PAPER_HOST / PAPER_PORT).

One attention block is 8 seconds. Blocks per attention year are stored as an octal literal.
EOF

mkdir -p spec/src corelib/src core/src api/src

########################################
# spec crate
########################################

cat > spec/Cargo.toml << 'EOF'
[package]
name = "dlog-spec"
version = "0.1.0"
edition = "2021"

[dependencies]
serde = { workspace = true }
EOF

cat > spec/src/lib.rs << 'EOF'
/// Omega monetary and network spec for dlog.
pub const PHI: f64 = 1.618_033_988_749_895;

/// Holder interest APY (61.8 percent).
pub const HOLDER_APY: f64 = 0.618;

/// Miner inflation APY (8.8248 percent).
pub const MINER_APY: f64 = 0.088_248;

/// Number of attention blocks per attention year, stored as an octal literal.
///
/// 0o16701140 octal = 3_900_000 decimal.
pub const BLOCKS_PER_ATTENTION_YEAR: u64 = 0o16701140;

/// Target duration of one attention block in seconds (octal 10 = 8).
pub const ATTENTION_BLOCK_SECONDS: u64 = 0o10;

/// Primary Infinity bank domain.
pub const DLOG_GOLD_DOMAIN: &str = "dlog.gold";

/// Rails for dlog.gold. Treat each as an Omega rail anchor in Google Cloud DNS.
pub const DLOG_GOLD_RAIL_IPS: [&str; 8] = [
    "34.138.180.68",
    "104.196.206.122",
    "34.26.186.252",
    "104.196.42.247",
    "35.229.25.192",
    "34.148.54.150",
    "34.148.48.238",
    "35.231.190.255",
];

/// Per block holder interest factor.
pub fn per_block_holder_factor() -> f64 {
    PHI.powf(1.0 / BLOCKS_PER_ATTENTION_YEAR as f64)
}

/// Per block miner inflation factor.
pub fn per_block_miner_factor() -> f64 {
    (1.0 + MINER_APY).powf(1.0 / BLOCKS_PER_ATTENTION_YEAR as f64)
}
EOF

########################################
# corelib crate
########################################

cat > corelib/Cargo.toml << 'EOF'
[package]
name = "dlog-corelib"
version = "0.1.0"
edition = "2021"

[dependencies]
serde = { workspace = true }
EOF

cat > corelib/src/lib.rs << 'EOF'
use serde::{Serialize, Deserialize};

#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
#[serde(rename_all = "lowercase")]
pub enum Planet {
    Earth,
    Moon,
    Mars,
    Sun,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PlanetMovementSpec {
    pub planet: Planet,
    /// Omega movement exponent k used in phi.powf(k).
    pub k: f64,
    /// Baseline per tick multiplier for this world.
    pub base_multiplier: f64,
    /// Effective multiplier phi^k per tick.
    pub tick_multiplier: f64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MonetarySpec {
    pub phi: f64,
    pub holder_apy: f64,
    pub miner_apy: f64,
    pub blocks_per_attention_year: u64,
    pub attention_block_seconds: u64,
    pub per_block_holder_factor: f64,
    pub per_block_miner_factor: f64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SnapshotSpec {
    pub version: String,
    pub dlog_gold_domain: String,
    pub dlog_gold_rails: Vec<String>,
    pub rails_per_static_ip: u64,
}

pub mod physics;
EOF

cat > corelib/src/physics.rs << 'EOF'
//! Physics cannon: phi-shaped Ω integrator for 8×8 rails.
//! - 1000 Hz tick (DT = 1 ms)
//! - Phi-based acceleration per planet
//! - Simple gravity and jump
//! - Speed clamp to keep clients honest

pub const PHI: f64 = 1.618_033_988_749_894_8;
pub const BLOCKS_PER_ATTENTION_YEAR: f64 = 3_900_000.0; // stored as octal in canon
pub const TICK_HZ: f64 = 1000.0;
pub const DT: f64 = 1.0 / TICK_HZ;

#[derive(Clone, Copy, Debug, Default)]
pub struct Vec3 {
    pub x: f64,
    pub y: f64,
    pub z: f64,
}

impl Vec3 {
    pub fn add(self, o: Self) -> Self {
        Self {
            x: self.x + o.x,
            y: self.y + o.y,
            z: self.z + o.z,
        }
    }

    pub fn scale(self, s: f64) -> Self {
        Self {
            x: self.x * s,
            y: self.y * s,
            z: self.z * s,
        }
    }

    pub fn length(self) -> f64 {
        (self.x * self.x + self.y * self.y + self.z * self.z).sqrt()
    }

    pub fn normalize(self) -> Self {
        let len = self.length();
        if len < 1e-9 {
            Self::default()
        } else {
            self.scale(1.0 / len)
        }
    }
}

#[derive(Clone, Copy, Debug)]
pub struct PlanetProfile {
    /// Phi exponent for this world (Earth ~1.0, Moon ~0.5, Mars ~0.8, Sun ~1.3).
    pub phi_exp: f64,
    /// Gravity magnitude (stylized; Ω-tuned).
    pub gravity: f64,
    /// Max horizontal speed clamp (to prevent runaway).
    pub max_speed: f64,
}

pub fn planet_earth() -> PlanetProfile {
    PlanetProfile {
        phi_exp: 1.0,
        gravity: 9.80665,
        max_speed: 50.0,
    }
}

pub fn planet_moon() -> PlanetProfile {
    PlanetProfile {
        phi_exp: 0.5,
        gravity: 1.62,
        max_speed: 35.0,
    }
}

pub fn planet_mars() -> PlanetProfile {
    PlanetProfile {
        phi_exp: 0.8,
        gravity: 3.71,
        max_speed: 40.0,
    }
}

pub fn planet_sun() -> PlanetProfile {
    PlanetProfile {
        phi_exp: 1.3,
        gravity: 274.0, // stylized; tune in practice
        max_speed: 80.0,
    }
}

#[derive(Clone, Copy, Debug, Default)]
pub struct Input {
    /// Desired movement direction (world space); will be normalized.
    pub wish_dir: Vec3,
    pub jump: bool,
}

#[derive(Clone, Copy, Debug)]
pub struct Body {
    pub pos: Vec3,
    pub vel: Vec3,
    pub on_ground: bool,
}

impl Default for Body {
    fn default() -> Self {
        Self {
            pos: Vec3::default(),
            vel: Vec3::default(),
            on_ground: true,
        }
    }
}

#[derive(Clone, Copy, Debug)]
pub struct TickResult {
    pub pos: Vec3,
    pub vel: Vec3,
    /// Optional: energy change in this tick (for rail accounting).
    pub energy_delta: f64,
}

/// Step one tick of Ω physics for a body.
pub fn step(body: Body, input: Input, profile: PlanetProfile) -> TickResult {
    let mut vel = body.vel;
    let wish = input.wish_dir.normalize();

    // Phi-based thrust magnitude per tick.
    let accel_mag = PHI.powf(profile.phi_exp);
    let accel = wish.scale(accel_mag);
    vel = vel.add(accel.scale(DT));

    // Gravity
    if !body.on_ground {
        vel.y -= profile.gravity * DT;
    } else if input.jump {
        // Stylized jump: sqrt(2*g*h). Use h ≈ 1.25m for flavor.
        let jump_v = (2.0 * profile.gravity * 1.25).sqrt();
        vel.y = jump_v;
    }

    // Horizontal clamp
    let horiz_speed = (vel.x * vel.x + vel.z * vel.z).sqrt();
    if horiz_speed > profile.max_speed {
        let scale = profile.max_speed / horiz_speed;
        vel.x *= scale;
        vel.z *= scale;
    }

    let pos = body.pos.add(vel.scale(DT));

    let old_ke = 0.5 * (body.vel.length().powi(2));
    let new_ke = 0.5 * (vel.length().powi(2));
    let energy_delta = new_ke - old_ke;

    TickResult { pos, vel, energy_delta }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn accelerates_with_phi() {
        let body = Body::default();
        let input = Input {
            wish_dir: Vec3 { x: 1.0, y: 0.0, z: 0.0 },
            jump: false,
        };
        let out = step(body, input, planet_earth());
        assert!(out.vel.x > 0.0);
        assert!(out.vel.x < planet_earth().max_speed);
    }

    #[test]
    fn jump_adds_upward_velocity() {
        let body = Body { on_ground: true, ..Default::default() };
        let input = Input {
            wish_dir: Vec3 { x: 0.0, y: 0.0, z: 0.0 },
            jump: true,
        };
        let out = step(body, input, planet_earth());
        assert!(out.vel.y > 0.0);
    }
}
EOF

########################################
# core crate
########################################

cat > core/Cargo.toml << 'EOF'
[package]
name = "dlog-core"
version = "0.1.0"
edition = "2021"

[dependencies]
dlog-spec = { path = "../spec" }
dlog-corelib = { path = "../corelib" }
serde = { workspace = true }
EOF

cat > core/src/lib.rs << 'EOF'
use dlog_spec::{
    PHI,
    HOLDER_APY,
    MINER_APY,
    BLOCKS_PER_ATTENTION_YEAR,
    ATTENTION_BLOCK_SECONDS,
    DLOG_GOLD_DOMAIN,
    DLOG_GOLD_RAIL_IPS,
    per_block_holder_factor,
    per_block_miner_factor,
};
use dlog_corelib::{Planet, PlanetMovementSpec, MonetarySpec, SnapshotSpec};

/// Full monetary spec, including per block factors.
pub fn monetary_spec() -> MonetarySpec {
    MonetarySpec {
        phi: PHI,
        holder_apy: HOLDER_APY,
        miner_apy: MINER_APY,
        blocks_per_attention_year: BLOCKS_PER_ATTENTION_YEAR,
        attention_block_seconds: ATTENTION_BLOCK_SECONDS,
        per_block_holder_factor: per_block_holder_factor(),
        per_block_miner_factor: per_block_miner_factor(),
    }
}

/// Planet movement spec across Earth, Moon, Mars, Sun.
pub fn planet_specs() -> Vec<PlanetMovementSpec> {
    let base = vec![
        (Planet::Earth, 1.0, 1.0),
        (Planet::Moon, 0.5, 0.5),
        (Planet::Mars, 0.8, 0.8),
        (Planet::Sun, 1.3, 1.3),
    ];

    base
        .into_iter()
        .map(|(planet, k, base_multiplier)| PlanetMovementSpec {
            planet,
            k,
            base_multiplier,
            tick_multiplier: PHI.powf(k),
        })
        .collect()
}

/// Snapshot of network level spec, including DNS rails.
pub fn snapshot_spec() -> SnapshotSpec {
    SnapshotSpec {
        version: "0.1.0".to_string(),
        dlog_gold_domain: DLOG_GOLD_DOMAIN.to_string(),
        dlog_gold_rails: DLOG_GOLD_RAIL_IPS
            .iter()
            .map(|s| s.to_string())
            .collect(),
        // Eight Omega rails per static IP, stored as octal.
        rails_per_static_ip: 0o10,
    }
}
EOF

########################################
# api crate
########################################

cat > api/Cargo.toml << 'EOF'
[package]
name = "dlog-api"
version = "0.1.0"
edition = "2021"

[dependencies]
axum = { workspace = true }
tokio = { workspace = true }
tracing = { workspace = true }
tracing-subscriber = { workspace = true }
serde = { workspace = true }
serde_json = { workspace = true }
futures = { workspace = true }
dlog-core = { path = "../core" }
dlog-corelib = { path = "../corelib" }
dlog-spec = { path = "../spec" }
EOF

cat > api/src/main.rs << 'EOF'
use axum::{
    extract::State,
    extract::ws::{Message, WebSocket, WebSocketUpgrade},
    http::{HeaderMap, StatusCode},
    response::IntoResponse,
    routing::{get, post},
    Json, Router,
};
use futures::{SinkExt, StreamExt};
use serde::{Deserialize, Serialize};
use dlog_core::{monetary_spec, planet_specs, snapshot_spec};
use dlog_corelib::{MonetarySpec, SnapshotSpec};
use dlog_corelib::physics::{
    self as omega_phys,
    Body as OmegaBody,
    Input as OmegaInput,
    PlanetProfile as OmegaPlanet,
    Vec3 as OmegaVec3,
    planet_earth,
};
use std::{net::SocketAddr, time::Duration};
use tokio::{
    io::{AsyncReadExt, AsyncWriteExt},
    net::{TcpListener, TcpStream},
    time::timeout,
};
use tracing_subscriber::{EnvFilter, prelude::*};

#[derive(Clone)]
struct AppState {
    paper_addr: SocketAddr,
}

impl AppState {
    fn from_env() -> Self {
        let host = std::env::var("PAPER_HOST").unwrap_or_else(|_| "127.0.0.1".to_string());
        let port = std::env::var("PAPER_PORT")
            .ok()
            .and_then(|p| p.parse::<u16>().ok())
            .unwrap_or(25565);

        let paper_addr = format!("{host}:{port}")
            .parse::<SocketAddr>()
            .expect("valid PAPER_HOST + PAPER_PORT");

        Self { paper_addr }
    }
}

#[tokio::main]
async fn main() {
    init_tracing();

    let state = AppState::from_env();

    let app = Router::new()
        .route("/", get(root))
        .route("/health", get(health))
        .route("/v1/hypercube/summary", get(hypercube))
        .route("/v1/spec/monetary", get(monetary))
        .route("/v1/spec/planets", get(planets))
        .route("/v1/spec/snapshot", get(snapshot))
        .route("/v1/paper/status", get(paper_status))
        .route("/ws/paper", get(ws_paper))
        // Bridge for the Minecraft plugin → Rust control loop.
        .route("/tick", post(tick))
        .with_state(state.clone());

    // Bind to PORT if set (Cloud Run), otherwise 8888 locally.
    let addr = listen_addr();
    tracing::info!("dlog Ω-api listening on http://{addr}");

    let listener = TcpListener::bind(addr).await.unwrap();
    axum::serve(listener, app).await.unwrap();
}

fn init_tracing() {
    let env_filter = std::env::var("RUST_LOG").unwrap_or_else(|_| "info,hyper=warn".to_string());

    let fmt_layer = tracing_subscriber::fmt::layer()
        .with_target(false)
        .with_line_number(true);

    tracing_subscriber::registry()
        .with(EnvFilter::new(env_filter))
        .with(fmt_layer)
        .init();
}

fn listen_addr() -> SocketAddr {
    let port = std::env::var("PORT")
        .ok()
        .and_then(|p| p.parse::<u16>().ok())
        .unwrap_or(8888);
    SocketAddr::from(([0, 0, 0, 0], port))
}

async fn root(State(state): State<AppState>) -> Json<serde_json::Value> {
    Json(serde_json::json!({
        "status": "ok",
        "phi": dlog_spec::PHI,
        "paper_backend": state.paper_addr.to_string(),
        "endpoints": [
            "/health",
            "/v1/hypercube/summary",
            "/v1/spec/monetary",
            "/v1/spec/planets",
            "/v1/spec/snapshot",
            "/v1/paper/status",
            "/ws/paper",
            "/tick"
        ]
    }))
}

async fn health() -> Json<serde_json::Value> {
    Json(serde_json::json!({
        "status": "ok",
        "phi": dlog_spec::PHI,
        "message": "Ω-heartbeat online"
    }))
}

async fn monetary() -> Json<MonetarySpec> {
    Json(monetary_spec())
}

#[derive(Serialize)]
struct PlanetsResponse {
    planets: Vec<PlanetGravityProfile>,
}

#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
pub struct PlanetGravityProfile {
    pub key: &'static str,
    pub surface_gravity_mps2: f64,
    pub shell_radius_m: f64,
    pub core_radius_m: f64,
}

const PLANET_PROFILES: &[PlanetGravityProfile] = &[
    PlanetGravityProfile {
        key: "sun",
        surface_gravity_mps2: 274.0,
        shell_radius_m: 695_700_000.0,
        core_radius_m: 139_140_000.0,
    },
    PlanetGravityProfile {
        key: "earth",
        surface_gravity_mps2: 9.80665,
        shell_radius_m: 6_371_000.0,
        core_radius_m: 3_500_000.0,
    },
    PlanetGravityProfile {
        key: "moon",
        surface_gravity_mps2: 1.62,
        shell_radius_m: 1_737_100.0,
        core_radius_m: 1_000_000.0,
    },
    PlanetGravityProfile {
        key: "mars",
        surface_gravity_mps2: 3.711,
        shell_radius_m: 3_389_500.0,
        core_radius_m: 1_800_000.0,
    },
];

async fn planets() -> Json<PlanetsResponse> {
    Json(PlanetsResponse {
        planets: PLANET_PROFILES.to_vec(),
    })
}

async fn snapshot() -> Json<SnapshotSpec> {
    Json(snapshot_spec())
}

// === Hypercube summary ===

#[derive(Serialize)]
struct HypercubeSummary {
    title: &'static str,
    sections: Vec<SummarySection>,
}

#[derive(Serialize)]
struct SummarySection {
    heading: &'static str,
    points: &'static [&'static str],
}

async fn hypercube() -> Json<HypercubeSummary> {
    Json(HypercubeSummary {
        title: "DLOG / Ω-Physics / Golden Wallet / Canon Spec v3 (hypercube summary)",
        sections: vec![
            SummarySection {
                heading: "Meta layers",
                points: &[
                    "NPC layer uses mainstream physics (seconds, meters) only when explicitly asked.",
                    "Ω layer is default: attention-driven time, phi as the core constant, base-8 rhythms.",
                ],
            },
            SummarySection {
                heading: "Coin and identity",
                points: &[
                    "DLOG is for self-investment and play, not fear-based scarcity.",
                    "Login via Apple or Google with biometrics; keys stay in device keystores; server sees signatures only.",
                    "No seed phrases for normal flows; SMS is never the only factor for critical moves.",
                ],
            },
            SummarySection {
                heading: "Golden Wallet Stack",
                points: &[
                    "Backed by three golden rivers (XAUT, BTC, DOGE) spread across 256 keys each.",
                    "Infinity Bank with Double Infinity Shield so no single actor can drain backing.",
                    "Luke is lore-level wealthy; focus is safe sharing and play.",
                ],
            },
            SummarySection {
                heading: "Monetary policy",
                points: &[
                    "Holder interest ~61.8% APY; miner inflation ~8.8248% APY; combined ~70% yearly expansion.",
                    "Per-block factors use phi curves; supply is intentionally expansive.",
                    "Blocks track attention cycles; humans can approximate as ~8 seconds.",
                ],
            },
            SummarySection {
                heading: "VORTEX, COMET, labels",
                points: &[
                    "Seven VORTEX wells plus one COMET wallet form the top genesis set (88,248 wallets total).",
                    "Labels map to phone numbers off-chain; each label is an Omega root with its own key.",
                    "Miners pay a small tithe to fill COMET; overflow flows into VORTEX wells.",
                ],
            },
            SummarySection {
                heading: "Filesystem",
                points: &[
                    "Universe encoded via 9∞ master root; each block unfolds and refolds state.",
                    "Per-label files use semicolon-delimited segments; dots are avoided in filenames and contents.",
                ],
            },
            SummarySection {
                heading: "Airdrops and gifts",
                points: &[
                    "88,248 genesis wallets; user airdrops decay on a phi curve.",
                    "Anti-farm: one per phone, Apple/Google ID, and public IP; VPN/datacenter IPs blocked.",
                    "Gifts are locked ~17 days; sending unlocks with phi-shaped limits after day 18.",
                ],
            },
            SummarySection {
                heading: "Land and game feel",
                points: &[
                    "Hollow planets (Earth, Moon, Mars, Sun) with shell/core inversion teleports.",
                    "Lock tiers: iron, gold, diamond, emerald; inactivity ~256 days triggers auction.",
                    "Movement blends Minecraft sandbox with CS:GO bhop/surf tuned by phi exponents per planet.",
                ],
            },
            SummarySection {
                heading: "Hosting and rails",
                points: &[
                    "Each static IP is eight Omega rails; scaling adds rails (attention lanes).",
                    "Rust-first workspace with spec/corelib/core/api as anchors; refold.command reshapes the tree.",
                ],
            },
        ],
    })
}

// === Ω tick bridge ===

#[derive(Debug, Deserialize)]
struct TickRequest {
    #[serde(default)]
    entities: Vec<EntityState>,
}

#[allow(dead_code)]
#[derive(Debug, Deserialize)]
struct EntityState {
    armor_stand_id: String,
    #[serde(default)]
    player_id: Option<String>,
    #[serde(default)]
    world_id: Option<String>,
    #[serde(default)]
    pos: Vec3,
    #[serde(default)]
    vel: Vec3,
    #[serde(default)]
    input: InputState,
}

#[derive(Debug, Deserialize, Default)]
struct InputState {
    #[serde(default)]
    forward: bool,
    #[serde(default)]
    back: bool,
    #[serde(default)]
    left: bool,
    #[serde(default)]
    right: bool,
    #[serde(default)]
    jump: bool,
    #[serde(default)]
    sneak: bool,
    #[serde(default)]
    on_ground: Option<bool>,
}

#[derive(Debug, Deserialize, Serialize, Default, Clone, Copy)]
struct Vec3 {
    #[serde(default)]
    x: f64,
    #[serde(default)]
    y: f64,
    #[serde(default)]
    z: f64,
}

#[derive(Debug, Serialize)]
struct TickResponse {
    updates: Vec<EntityUpdate>,
}

#[derive(Debug, Serialize)]
struct EntityUpdate {
    armor_stand_id: String,
    pos: Vec3,
    vel: Vec3,
}

async fn tick(headers: HeaderMap, axum::extract::Json(req): axum::extract::Json<TickRequest>) -> Result<Json<TickResponse>, StatusCode> {
    // Optional auth: set OMEGA_TICK_TOKEN to require X-Auth-Token header.
    if let Ok(expected) = std::env::var("OMEGA_TICK_TOKEN") {
        let ok = headers
            .get("x-auth-token")
            .and_then(|v| v.to_str().ok())
            .map(|v| v == expected)
            .unwrap_or(false);
        if !ok {
            return Err(StatusCode::UNAUTHORIZED);
        }
    }

    // Ω physics cannon: integrate using phi-shaped movement and gravity.
    // Incoming ticks are ~20 Hz; we substep at 1 kHz to keep integration stable.
    const TICK_DT: f64 = 0.05; // 50 ms per incoming tick
    let substeps = (TICK_DT / omega_phys::DT).round().max(1.0) as usize;
    let planet: OmegaPlanet = planet_earth();
    let mut updates = Vec::with_capacity(req.entities.len());

    for mut e in req.entities {
        let wish = OmegaVec3 {
            x: dir_input(e.input.right as i32 - e.input.left as i32),
            y: 0.0,
            z: dir_input(e.input.forward as i32 - e.input.back as i32),
        };
        let mut body = OmegaBody {
            pos: OmegaVec3 { x: e.pos.x, y: e.pos.y, z: e.pos.z },
            vel: OmegaVec3 { x: e.vel.x, y: e.vel.y, z: e.vel.z },
            on_ground: e.input.on_ground.unwrap_or(true),
        };
        let omega_in = OmegaInput { wish_dir: wish, jump: e.input.jump };

        for _ in 0..substeps {
            let out = omega_phys::step(body, omega_in, planet);
            body.pos = out.pos;
            body.vel = out.vel;
            // simple ground latch: if y <= 0, clamp to ground and zero vertical velocity
            if body.pos.y <= 0.0 {
                body.pos.y = 0.0;
                body.vel.y = 0.0;
                body.on_ground = true;
            }
        }

        updates.push(EntityUpdate {
            armor_stand_id: e.armor_stand_id,
            pos: Vec3 { x: body.pos.x, y: body.pos.y, z: body.pos.z },
            vel: Vec3 { x: body.vel.x, y: body.vel.y, z: body.vel.z },
        });
    }

    Ok(Json(TickResponse { updates }))
}

fn dir_input(n: i32) -> f64 {
    if n > 0 { 1.0 } else if n < 0 { -1.0 } else { 0.0 }
}

// === Paper shim (HTTP/WS bridge) ===

async fn paper_status(State(state): State<AppState>) -> Json<serde_json::Value> {
    let addr = state.paper_addr;
    let online = timeout(Duration::from_secs(2), TcpStream::connect(addr))
        .await
        .ok()
        .and_then(|res| res.ok())
        .is_some();

    Json(serde_json::json!({
        "address": addr.to_string(),
        "online": online,
    }))
}

async fn ws_paper(
    State(state): State<AppState>,
    ws: WebSocketUpgrade,
) -> impl IntoResponse {
    let addr = state.paper_addr;
    ws.on_upgrade(move |socket| handle_ws(socket, addr))
}

async fn handle_ws(socket: WebSocket, paper_addr: SocketAddr) {
    tracing::info!("ws bridge connecting to Paper backend at {}", paper_addr);

    match TcpStream::connect(paper_addr).await {
        Ok(backend) => {
            if let Err(err) = pipe_ws_to_tcp(socket, backend).await {
                tracing::warn!("ws bridge error: {}", err);
            }
        }
        Err(err) => {
            tracing::warn!("failed to connect to Paper backend {}: {}", paper_addr, err);
        }
    }
}

async fn pipe_ws_to_tcp(
    socket: WebSocket,
    backend: TcpStream,
) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
    let (mut ws_tx, mut ws_rx) = socket.split();
    let (mut tcp_reader, mut tcp_writer) = backend.into_split();

    let to_tcp = async {
        while let Some(msg) = ws_rx.next().await {
            let msg = msg?;
            match msg {
                Message::Binary(bytes) => {
                    tcp_writer.write_all(&bytes).await?;
                }
                Message::Text(text) => {
                    tcp_writer.write_all(text.as_bytes()).await?;
                    tcp_writer.write_all(b"\n").await?;
                }
                Message::Close(_) => break,
                Message::Ping(_) | Message::Pong(_) => {}
            }
        }
        let _ = tcp_writer.shutdown().await;
        Ok::<(), Box<dyn std::error::Error + Send + Sync>>(())
    };

    let to_ws = async {
        let mut buf = [0u8; 4096];
        loop {
            let n = tcp_reader.read(&mut buf).await?;
            if n == 0 {
                break;
            }
            ws_tx.send(Message::Binary(buf[..n].to_vec())).await?;
        }
        let _ = ws_tx.send(Message::Close(None)).await;
        Ok::<(), Box<dyn std::error::Error + Send + Sync>>(())
    };

    tokio::select! {
        res = to_tcp => { res?; }
        res = to_ws => { res?; }
    }

    Ok(())
}
EOF

########################################
# dlog.command launcher
########################################

cat > dlog.command << 'EOF'
#!/usr/bin/env bash
set -euo pipefail

cd "$(dirname "$0")"

export RUST_LOG="${RUST_LOG:-info,dlog_api=debug}"

cargo run -p dlog-api -- "$@"
EOF

chmod +x dlog.command

echo "[dlog] workspace ready at ${ROOT}"
echo "[dlog] to run the API: cd ${ROOT} && ./dlog.command"
